NERoomKit 自 V1.42.0 版本起，提供完整的拉流播放解决方案，支持多实例播放、状态监听等功能。

::: note note
当前版本仅支持 RTMP 协议，其他协议支持将在后续版本中陆续推出。
:::

## 实现流程

### 步骤一：添加监听器

:::::: div linked-codes
::: code Kotlin
```kotlin
// 获取 PlayerService
val playerService = NERoomKit.getInstance().getService(NEPlayerService::class.java)

// 添加播放器监听器
val playerListener = object : NEPlayerListener {
    override fun onPlayStreamingStateChanged(player: NEPlayer, state: NEPlayStreamingState, code: Int) {
        // 处理状态变化（PLAYING/STOPPED/RECONNECTING/PAUSED/IDLE）
    }

    override fun onPlayStreamingReceiveSeiMessage(player: NEPlayer, message: String) {
        // 处理 SEI 消息
    }

    override fun onPlayStreamingFirstAudioFramePlayed(player: NEPlayer, timeMs: Long) {
        // 处理首帧音频播放
    }

    override fun onPlayStreamingFirstVideoFrameRender(player: NEPlayer, timeMs: Long, width: Int, height: Int) {
        // 处理首帧视频渲染
    }
}
playerService.addListener(playerListener)

// 移除播放器监听器
playerService.removeListener(playerListener)
```
::: 
::: code Java
```java
// 获取 PlayerService
NEPlayerService playerService = NERoomKit.getInstance().getService(NEPlayerService.class);

// 添加播放器监听器
NEPlayerListener playerListener = new NEPlayerListener() {
    @Override
    public void onPlayStreamingStateChanged(NEPlayer player, NEPlayStreamingState state, int code) {
        // 处理状态变化（PLAYING/STOPPED/RECONNECTING/PAUSED/IDLE）
    }

    @Override
    public void onPlayStreamingReceiveSeiMessage(NEPlayer player, String message) {
        // 处理 SEI 消息
    }

    @Override
    public void onPlayStreamingFirstAudioFramePlayed(NEPlayer player, long timeMs) {
        // 处理首帧音频播放
    }

    @Override
    public void onPlayStreamingFirstVideoFrameRender(NEPlayer player, long timeMs, int width, int height) {
        // 处理首帧视频渲染
    }
};
playerService.addListener(playerListener);

// 移除播放器监听器
playerService.removeListener(playerListener);
```
:::
::::::

### 步骤二：创建播放器实例

:::::: div linked-codes
::: code Kotlin
```kotlin
// 创建播放器实例（需自行维护生命周期）
val player = playerService.createPlayer()
```
:::
::: code Java
```java
// 创建播放器实例（需自行维护生命周期）
NEPlayer player = playerService.createPlayer();
```
:::
::::::

### 步骤三：设置视频画布

:::::: div linked-codes
::: code Kotlin
```kotlin
// 创建并设置渲染画布
val videoView = NERoomVideoView(context)
// 将渲染视图添加到容器（示例）
container.addView(videoView)

// 绑定画布
val setupResult = player.setupCanvas(videoView)
if (setupResult == 0) {
    // 画布设置成功
} else {
    // 画布设置失败，处理错误码
}
```
:::
::: code Java
```java
// 创建并设置渲染画布
NERoomVideoView videoView = new NERoomVideoView(context);
// 将渲染视图添加到容器（示例）
container.addView(videoView);

// 绑定画布
int setupResult = player.setupCanvas(videoView);
if (setupResult == 0) {
    // 画布设置成功
} else {
    // 画布设置失败，处理错误码
}
```
:::
::::::

### 步骤四：开始播放流媒体

:::::: div linked-codes
::: code Kotlin
```kotlin
// 配置拉流参数
val config = NEPlayStreamingConfig().apply {
    streamingUrl = "rtmp://example.com/stream" // 或其他协议地址
    playOutDelay = 2000           // 可选：播放出声延迟（ms）
    reconnectTimeout = 30_000     // 可选：重连超时（ms）
    muteAudio = false             // 可选：启动时是否静音音频
    muteVideo = false             // 可选：启动时是否静音视频
    pausePullStream = false       // 可选：启动时是否暂停拉流
}

// 开始播放
val startResult = player.start(config)
if (startResult != 0) {
    // 启动失败，处理错误码
}
```
:::
::: code Java
```java
// 配置拉流参数
NEPlayStreamingConfig config = new NEPlayStreamingConfig();
config.setStreamingUrl("rtmp://example.com/stream"); // 或其他协议地址
config.setPlayOutDelay(2000);          // 可选：播放出声延迟（ms）
config.setReconnectTimeout(30_000);    // 可选：重连超时（ms）
config.setMuteAudio(false);            // 可选：启动时是否静音音频
config.setMuteVideo(false);            // 可选：启动时是否静音视频
config.setPausePullStream(false);      // 可选：启动时是否暂停拉流

// 开始播放
int startResult = player.start(config);
if (startResult != 0) {
    // 启动失败，处理错误码
}
```
:::
::::::

### 步骤五：播放控制操作

:::::: div linked-codes
::: code Kotlin
```kotlin
// 暂停播放
player.pause()

// 恢复播放
player.resume()

// 静音视频
player.muteVideo(true)

// 静音音频
player.muteAudio(true)

// 停止播放
player.stop()
```
:::
::: code Java
```java
// 暂停播放
player.pause();

// 恢复播放
player.resume();

// 静音视频
player.muteVideo(true);

// 静音音频
player.muteAudio(true);

// 停止播放
player.stop();
```
:::
::::::

### 步骤六：资源释放

:::::: div linked-codes
::: code Kotlin
```kotlin
// 停止并销毁播放器实例
player.stop()
playerService.destroyPlayer(player)
```
:::
::: code Java
```java
// 停止并销毁播放器实例
player.stop();
playerService.destroyPlayer(player);
```
:::
::::::

## API 参考 

类/方法/回调/错误码 | 说明
--- | ---
[`NEPlayerService`]() | 拉流播放器管理服务，负责播放器实例的创建与生命周期管理。
[`NEPlayer`]() | 拉流播放器类，提供完整的播放控制能力。
[`NEPlayerListener`]() | 拉流播放器事件监听器，提供全面的状态变化、SEI消息和首帧渲染等回调。

## 事件回调

- **状态枚举**：`NEPlayStreamingState` 包含 `PLAYING`、`STOPPED`、`RECONNECTING`、`PAUSED`、`IDLE`
- **关键回调**（实现于 `NEPlayerListener`）：

  - `onPlayStreamingStateChanged(player, state, code)`
  - `onPlayStreamingReceiveSeiMessage(player, message)`
  - `onPlayStreamingFirstAudioFramePlayed(player, timeMs)`
  - `onPlayStreamingFirstVideoFrameRender(player, timeMs, width, height)`

## 返回值与错误码

控制方法通常返回 `Int`，其中 `0` 表示成功，非零表示失败。请根据返回值进行错误处理与兜底逻辑。具体的错误码请参考 [RTC 错误码](https://doc.yunxin.163.com/nertc/client-apis/jUxMjc0OTY?platform=android)。

## 常见问题

### 如何同时播放多个流媒体？

创建多个 `NEPlayer` 实例，每个实例对应一个流，并分别设置画布与配置：

::: note note
- `NEPlayerService.createPlayer()` 可多次调用创建多个 `NEPlayer` 实例，分别绑定不同的 `NERoomVideoView` 并播放不同流地址。
- 请为每个实例独立管理生命周期，并在不再使用时调用 `destroyPlayer(player)` 释放资源。
:::

:::::: div linked-codes
::: code Kotlin
```kotlin
val service = NERoomKit.getInstance().getService(NEPlayerService::class.java)
val player1 = service.createPlayer()
val player2 = service.createPlayer()

val view1 = NERoomVideoView(context)
val view2 = NERoomVideoView(context)
container1.addView(view1)
container2.addView(view2)

player1.setupCanvas(view1)
player2.setupCanvas(view2)

val cfg1 = NEPlayStreamingConfig().apply { streamingUrl = "rtmp://example.com/stream1" }
val cfg2 = NEPlayStreamingConfig().apply { streamingUrl = "rtmp://example.com/stream2" }
player1.start(cfg1)
player2.start(cfg2)
```
:::
::: code Java
```java
NEPlayerService service = NERoomKit.getInstance().getService(NEPlayerService.class);
NEPlayer player1 = service.createPlayer();
NEPlayer player2 = service.createPlayer();

NERoomVideoView view1 = new NERoomVideoView(context);
NERoomVideoView view2 = new NERoomVideoView(context);
container1.addView(view1);
container2.addView(view2);

player1.setupCanvas(view1);
player2.setupCanvas(view2);

NEPlayStreamingConfig cfg1 = new NEPlayStreamingConfig();
cfg1.setStreamingUrl("rtmp://example.com/stream1");
NEPlayStreamingConfig cfg2 = new NEPlayStreamingConfig();
cfg2.setStreamingUrl("rtmp://example.com/stream2");
player1.start(cfg1);
player2.start(cfg2);
```
:::
::::::

### 如何处理播放失败？

通过监听 `onPlayStreamingStateChanged` 回调，检查状态和错误码：

:::::: div linked-codes
::: code Kotlin
```kotlin
val listener = object : NEPlayerListener {
    override fun onPlayStreamingStateChanged(player: NEPlayer, state: NEPlayStreamingState, code: Int) {
        if (state == NEPlayStreamingState.STOPPED && code != 0) {
            // 播放失败
            // TODO: 提示用户并根据业务进行重试或其他交互
        }
    }
}
service.addListener(listener)
```
:::
::: code Java
```java
NEPlayerListener listener = new NEPlayerListener() {
    @Override
    public void onPlayStreamingStateChanged(NEPlayer player, NEPlayStreamingState state, int code) {
        if (state == NEPlayStreamingState.STOPPED && code != 0) {
            // 播放失败
            // TODO: 提示用户并根据业务进行重试或其他交互
        }
    }
};
service.addListener(listener);
```
:::
::::::

### 如何获取播放器状态？

通过 `onPlayStreamingStateChanged` 回调实时监听状态变化并在业务侧保存当前状态。

### 支持哪些拉流协议？

当前版本基于 RTC SDK 实现，目前仅支持 RTMP 协议。后续会陆续支持其他协议。